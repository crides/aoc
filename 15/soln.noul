d1a := \inp -> (inp count "(") * 2 - len(inp);
d1b := \inp -> (inp scan (\a, x -> a + (if (x == "(") 1 else -1)) from 0) locate (-1);

d2a := \inp -> lines(inp) map (\l -> (
    x, y, z := l split("x") map int;
    as := sort([x * y, y * z, x * z]);
    as[0] * 3 + 2 * sum(as[1:])
)) then sum;
d2b := \inp -> lines(inp) map (\l -> (
    sides := sort(l split("x") map int);
    2 * sum(sides[:2]) + product(sides)
)) then sum;

dbg := \v -> (print(v); v);
d3_off_dirs := [V(0, 1), V(-1, 0), V(0, -1), V(1, 0)];
d3_poss := \inp -> unique(inp scan (\p, c -> p + d3_off_dirs[">^<v" locate c]) from V(0, 0));
d3a := d3_poss >>> len;
d3b := \inp -> len(unique(enumerate(inp) partition first >>> even map map(second) flat_map d3_poss));

d4s := \s -> \inp -> iota(0) lazy_map (\i -> hex_encode(md5(bytes(inp $ i)))) locate starts_with(s);
d4a := d4s("00000");
d4b := d4s("000000");

d5a := \inp -> lines(inp) count \l -> (l count in("aeiou")) >= 3 and l window 2 any (\[x, y] -> x == y) and ["ab", "cd", "pq", "xy"] all not_in(l);
d5b := \inp -> lines(inp) count \l -> enumerate(l window 2) group_all second any (_ map first combinations 2 any (\[x, y] -> abs(x - y) >= 2)) and l window 3 any (\[x, y, z] -> x == z);

d6a := \inp -> (
    lines(inp) fold (\acc, l -> (
        end, _, start, inst := l rsplit " " by 4;
        start .= (_ split ",") >>> map(int);
        end .= (_ split ",") >>> map(int);
        switch (len(inst)) 
        case 6 -> for (i <- start[0] to end[0]; j <- start[1] to end[1]) acc[i][j] .= not
        case 7 -> for (i <- start[0] to end[0]; j <- start[1] to end[1]) acc[i][j] = 1
        case 8 -> for (i <- start[0] to end[0]; j <- start[1] to end[1]) acc[i][j] = 0;
        acc
    )) from ((0 .* 1000) .* 1000) map count(== 1) then sum
);
d6b := \inp -> (
    lines(inp) fold (\acc, l -> (
        end, _, start, inst := l rsplit " " by 4;
        start .= (_ split ",") >>> map(int);
        end .= (_ split ",") >>> map(int);
        switch (len(inst)) 
        case 6 -> for (i <- start[0] to end[0]; j <- start[1] to end[1]) acc[i][j] += 2
        case 7 -> for (i <- start[0] to end[0]; j <- start[1] to end[1]) acc[i][j] += 1
        case 8 -> for (i <- start[0] to end[0]; j <- start[1] to end[1]) acc[i][j] = (acc[i][j] - 1) max 0;
        acc
    )) from ((0 .* 1000) .* 1000) map sum then sum
);

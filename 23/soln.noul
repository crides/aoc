d1a := (\inp ->
    inp then lines map (\l -> l search_all(R"\d")) map (\l -> int(l[0] $ l[-1])) then sum
);

d1b := (\inp -> (
    L := ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
    fpat := R"\d|" $ (L join "|");
    bpat := R".*(\d" $ (L map ("|"$) join "") $ ")";
    inp then lines map (\l -> (
        front := l search fpat;
        back := (l search bpat) !! 1;
        l = (front .. back) map (\i-> if (i =~ R"\d") i else $((L locate i) + 1)) join "";
        int(l)
    )) then sum
));

d2p := (\inp -> (
    col_color := (\c, g -> g map (\s -> (s !? c) coalesce 0) then max);
    inp then lines
    map (\l ->
        l[5:] split ": "
        then (int *** (\g ->
            g split "; " map (\s ->
                s split ", " map (\c ->
                    c split " " then (int *** id) then reverse) then dict)
            then ("red"(col_color) &&& "green"(col_color) &&& "blue"(col_color)) )))
));

d2a := (\inp -> d2p(inp) filter (\p -> all(p[1] zip (12 to 14) with (<))) map first then sum);
d2b := (\inp -> d2p(inp) map (\p -> product(p[1])) then sum);

d3p := (\inp, cond -> (
    ls := lines(inp);
    li := (\l -> (
        infs := [];
        o := 0;
        while (1) (
            n := l search R"\d+";
            if (n == null) return infs;
            i := l locate n;
            infs +.= [int(n), i + o, i + o + len(n)];
            l = l[i + len(n):];
            o = i + len(n) + o;
        );
    ));
    lis := enumerate(ls) map (\[i, l] -> li(l) map (\inf -> [inf[0], i, inf[1], inf[2]])) then flatten;
    sli := (\l -> enumerate(list(l)) filter (\p -> cond(p[1])));
    slis := ls map sli then enumerate map (\[i, infs] -> infs map (\[j, s] -> [i, j])) then flatten;
    [ls, lis, slis]
));

d3a := (\inp -> (
    ls, lis, slis := d3p(inp, (\c -> c != '.' and (c < '0' or c > '9')));
    sis := slis map (\c -> [-1, 0, 1] ^^ 2 map (\o -> vector(c) + vector(o))) then flatten;
    lis filter (\linf -> sis any (\c -> c[0] == linf[1] and linf[2] <= c[1] < linf[3])) map first then sum
));

d3b := (\inp -> (
    ls, lis, slis := d3p(inp, (== '*'));
    slis map (\sl -> (
        [-1, 0, 1] ^^ 2 map (\o -> vector(sl) + vector(o)) map (\c -> lis filter (\linf -> c[0] == linf[1] and linf[2] <= c[1] < linf[3])) then flatten then set
    ))
    filter (\i -> len(i) == 2) then map (\ns -> ns map first then product) then sum
));

d4p := (\inp -> (
    lines(inp) map (\l -> l split ": " then second then (\s -> s split " | " map (\g -> g search_all R"\d+" then set) fold &&))
));
d4a := (\inp -> d4p(inp) map (\l -> floor(2 ^ (len(l) - 1))) then sum);
d4b := (\inp -> (
    cis := enumerate(d4p(inp)) map (\[i, l] -> 1 to len(l) map (+i));
    mult := cis map (const 1);
    for (i, ci <<- cis) for (j <- ci) mult[j] += mult[i];
    sum(mult)
));

d5p := (\inp -> (
    ps := inp split "\n\n";
    seeds := ps[0] split ": " then second split " " map int;
    maps := ps[1:] map (\m -> lines(m)[1:] map (\l -> l split " " map int));
    [seeds, maps]
));
d5a := (\inp -> (
    seeds, maps := d5p(inp);
    for (m <- maps) (
        seeds = seeds map (\s -> (
            for ([t, b, l] <- m) if (b <= s < (b + l)) return s - b + t;
            s
        ));
    );
    min(seeds)
));
d5b := (\inp -> (
    seeds, maps := d5p(inp);
    maps fold (\ss, m -> (
        ss map (\ir -> (
            m fold (\[rest, next], [t, b, l] -> (
                new_rest, new_next := rest map (\[s, sl] -> 
                    if ((s + sl) <= b or s >= (b + l)) (
                        [[[s, sl]], []]
                    ) else (
                        ins, ine := max(s, b), min(s + sl, b + l);
                        ((if (s < b) [[s, b - s]] else []) ++
                            (if ((s + sl) > (b + l)) [[b + l, s + sl - b - l]] else [])) ..
                        [[ins - b + t, ine - ins]]
                    )
                ) then transpose map flatten or [[], []];
                [new_rest, next ++ new_next]
            )) from [[ir], []] fold ++
        )) then flatten
    )) from (seeds group 2) map first then min
));

d6a := (\inp ->
    lines(inp) map (\l -> l search_all(R"\d+") map int) then transpose
    map (\[t, dist] -> (1 til t) map (\i -> i * (t - i) > dist) then sum) then product
);
# (time - x) * x > dist
# => time * x - x^2 > dist
# => x^2 - time * x + dist < 0
# get roots: (-time +- sqrt(time^2 - 4 * dist)) / 2
d6b := (\inp -> (
    tim, dist := lines(inp) map (\l -> l split ": " then second replace R"\s+" with "" then int);
    ((V(-1, 1) * sqrt(tim ^ 2 - 4 * dist) - tim) / 2 fold - then abs then floor) + 1
));

d7_rank := (\proc, order -> \[card, b] -> (
    v := proc(frequencies(card));
    [-(len(v)), v[-1]] ++ (card map (order locate _))
));
d7s := (\order, proc -> \inp -> (
    cards := lines(inp) map (\l -> l split(" ") then (id *** int));
    cards sort (<=> on d7_rank(proc, order)) then enumerate map (\[i, [c, b]] -> (i + 1) * b) then sum
));
d7a := d7s("23456789TJQKA", \freq -> sort(values(freq)));
d7b := d7s("J23456789TQKA", \freq -> (
    v := sort(values(freq -. "J"));
    if (len(v) == 0) [5] else v[:-1] +. (v[-1] + freq["J"])
));

d8p := (\inp -> (
    ls := lines(inp);
    insts := ls[0];
    net := ls[2:] map (_ replace "[()]" with "" split " = " then (id *** (_ split ", "))) then dict;
    [insts, net]
));
d8a := (\inp -> (
    insts, net := d8p(inp);
    node := "AAA";
    for (i, inst <<- cycle(insts)) (
        node = net[node][inst == "R"];
        if (node == "ZZZ") return i + 1;
    )
));
d8b := (\inp -> (
    insts, net := d8p(inp);
    steps := (\node -> (
        for (i, inst <<- cycle(insts)) (
            node = net[node][inst == "R"];
            if (node ends_with "Z") return i + 1;
        )
    ));
    nodes := keys(net) filter (_ ends_with "A");
    nodes map steps fold lcm
));

d9p := (\inp ->
    lines(inp) map (\l -> l split " " map int)
    map (\seq -> (
        preds := [seq];
        while (1) (
            preds +.= preds[-1] pairwise flip(-);
            if (preds[-1] all (==0)) return preds;
        )
    ))
);
d9a := (\inp -> d9p(inp) map (\preds -> preds map last then sum) then sum);
d9b := (\inp -> d9p(inp) map (\preds -> preds map first then reverse fold (\s, i -> i - s)) then sum);

d10_off_dirs := {0: V(0, 1), 3: V(1, 0), 2: V(0, -1), 1: V(-1, 0)};
d10_net_get := (\net, [r, c] -> if (0 <= c < len(net[0]) and 0 <= r < len(net)) net[r][c] else null);
d10p := (\inp -> (
    net := lines(inp) map (\l -> l map (\c ->
        if (c == "F") {0, 3}
        else if (c == "J") {1, 2}
        else if (c == "|") {1, 3}
        else if (c == "-") {0, 2}
        else if (c == "7") {2, 3}
        else if (c == "L") {0, 1}
        else null
    ));
    start := enumerate(lines(inp)) find (\[i, l] -> (l locate? "S") != null) then (id *** (_ locate "S")) then vector;
    start_dirs := items(d10_off_dirs) filter (\[cur_dir, off] -> (
        next := d10_net_get(net, start + off);
        (next != null and ((cur_dir + 2) % 4) in next)
    ));
    net[start[0]][start[1]] = start_dirs map first then set;
    loop := {};
    cur := start;
    cur_dir := start_dirs[0][0];
    while (1) (
        loop |.= cur;
        off := d10_off_dirs[cur_dir];
        next_pos := cur + off;
        next := d10_net_get(net, next_pos);
        cur_dir = only(list(next -. ((cur_dir + 2) % 4)));
        cur = next_pos;
        if (cur == start) break;
    );
    [net, start, start_dirs, loop]
));

d10a := (\inp -> len(d10p(inp)[3]) // 2);
d10b := (\inp -> (
    net, start, start_dirs, loop := d10p(inp);
    rows, cols := len(net), len(net[0]);
    seged := net map (\l -> l map const(0));

    cur := start;
    cur_dir := start_dirs[0][0];
    wall := 0;
    while (1) (
        off := d10_off_dirs[cur_dir];
        cur_tail := only(list(d10_net_get(net, cur) -. cur_dir));
        rights := cur_dir iterate (\d -> if (d == cur_tail) break else (d - 1) %% 4) map (.. 2);
        lefts := cur_dir iterate (\d -> if (d == cur_tail) break else (d + 1) %% 4) map (.. 1);
        for ([dir, mark] <- (rights ++ lefts)) (
            ray_off := d10_off_dirs[dir];
            ray := cur + ray_off;
            while (ray not_in loop or d10_net_get(net, ray) == null) (
                if (0 <= ray[0] < rows and 0 <= ray[1] < cols) (
                    seged[ray[0]][ray[1]] = mark;
                    ray += ray_off;
                ) else (
                    wall = mark;
                    break;
                )
            );
        );
        next_pos := cur + off;
        next := d10_net_get(net, next_pos);
        cur_dir = only(list(next -. ((cur_dir + 2) % 4)));
        cur = next_pos;
        if (cur == start) break;
    );
    flatten(seged) count (==(3-wall))
));

d11p := (\inp -> (
    mmap := lines(inp) map (\l -> l map (=="#"));
    empty_rows := enumerate(mmap) filter (\[i, l] -> l all (== 0)) map first;
    empty_cols := enumerate(transpose(mmap)) filter (\[i, l] -> l all (== 0)) map first;
    [mmap, empty_rows, empty_cols]
));
d11_find_locs := (\mmap -> 
    enumerate(mmap) filter (\[r, l] -> l any (== 1)) map (\[r, l] -> (
        enumerate(l) filter (\[c, p] -> p) map (\[c, p] -> V(r, c))
    )) then flatten
);
d11a := (\inp -> (
    mmap, empty_rows, empty_cols := d11p(inp);
    for (r <- reverse(empty_rows)) mmap = mmap[:r] ++ (mmap[r] .* 2) ++ mmap[r + 1:];
    for (c <- reverse(empty_cols)) mmap = mmap map (\l -> l[:c] ++ (l[c] .* 2) ++ l[c + 1:]);
    locs := d11_find_locs(mmap);
    combinations(locs, 2) then map (\[a, b] -> sum(abs(a - b))) then sum
));
d11b := (\inp -> (
    mmap, empty_rows, empty_cols := d11p(inp);
    empty_rows .= set;
    empty_cols .= set;
    locs := d11_find_locs(mmap);
    dist := (\a, b -> (
        mmrow := (min &&& max)([a[0], b[0]]);
        mmcol := (min &&& max)([a[1], b[1]]);
        erows := len(empty_rows && set((mmrow[0] + 1) til mmrow[1]));
        ecols := len(empty_cols && set((mmcol[0] + 1) til mmcol[1]));
        sum(abs(a - b)) + (erows + ecols) * 999999
    ));
    combinations(locs, 2) map (\p -> dist(...p)) then sum
));

d12p := (\inp ->
    lines(inp) map (_ split " " then (_ map ("#?." locate _)) *** (_ split "," map int))
);
d12s := (\recs -> (
    recs map (\[spots, counts] -> (
        dp := counts map const(spots map const(0));
        starts := 0 til (len(spots) - counts[0]) filter (\i -> spots[i:i + counts[0]] all (!= 2));
        for (start <- starts) if (spots[:start] all (!= 0)) dp[0][start + counts[0] - 1] = 1;
        for (i <- 1 til len(counts)) (
            for (j <- 0 til (len(spots) - counts[i] + 1)) (
                prev := 0 til (j - 1) filter (\k -> spots[k + 1:j] all (!= 0)) map (\k -> dp[i - 1][k]) then sum;
                if (prev > 0 and (j == 0 or spots[j - 1] != 0) and spots[j:j + counts[i]] all (!= 2) and (i < (len(counts) - 1) or spots[j + counts[i]:] all (!= 0))) (
                    dp[i][j + counts[i] - 1] = prev;
                )
            )
        );
        sum(dp[-1])
    )) then sum
));
d12a := (\inp -> d12s(d12p(inp)));
d12b := (\inp -> (
    recs := d12p(inp);
    recs = recs map (\[spots, counts] -> (
        new_spots := flatten((spots +. 0) ** 4) ++ spots;
        new_counts := counts ** 5;
        [new_spots, new_counts]
    ));
    d12s(recs)
));
